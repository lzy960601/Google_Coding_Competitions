# 2022 Round A

-   Score : 100
-   Rank : 60
-   工作闲暇打一下，手更生了= =
---

## A

- 简单的数学分析得知，最小的那些数字挤在一起，其余数字一个数一个桶即为最优解

## B

- 本质上是两个序列，各取一部分前缀和后缀，要求和最大
- 利用前后缀和，预处理每个序列取固定数目的最大和
- 然后把两个序列答案合并即可

## C

- 动态规划，$dp_{i,j}$表示当前敲了$i$个字符，位置在$j$的最小时间
- 如果直接枚举当前位置$j$和上一次位置$k$暴力转移显然会超时
- 我们考虑拆分$|j - k|$，本质上是维护两种情况
  - $j \leq k$，则是$dp_{i-1,k} + j - k$，前缀扫一遍记录$dp_{i-1,k}-k$的最小值即可
  - $j \gt k$的情况同理

## D

- 一开始就想到了经典的有向图，SCC缩点转DAG然后拓扑排序的套路
- 但是完全没想明白$K \leq 20$有什么作用，所以对这个做法很慌张
- 后面写的时候发现需要维护DAG上节点的传递闭包，这里的$K$可以有效减小时间复杂度
- 之后对这个做法就非常自信了
- 考虑$x$声明$y$是好人，等价于$y$是坏人$\rightarrow$$x$是坏人
- 我们将坏人的有向传递关系转SCC缩点变成DAG，这里就变成"一群人$Y$是坏人$\rightarrow$一群人$X$是坏人"
- 那么一群人有可能是坏人，当前仅当他们影响到的总人数不超过$K$
- 这里在拓扑排序时根据$K$的限制加点骚操作判断一下即可
- 总复杂度不超过$O(NK^2\log)$(这里的$\log$是因为我偷懒用了set)
